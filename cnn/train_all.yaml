name: Train v4
description: Trains a CNN model using nesyfactory with CAFO and Forward-Forward support
inputs:
  - name: data_path
    type: Dataset
  - name: config
    type: String
  - name: model_input
    type: Model
    description: "Input model (either freshly built or loaded from CDN)"
  - name: mapping_json
    type: String
    description: "Mapping configuration for history processing"
    default: "{}"
  - name: max_history_rows
    type: Integer
    description: "Maximum number of history rows to output"
    default: "5"
outputs:
  - name: trained_model
    type: Model
  - name: training_history
    type: String
  - name: processed_history_json
    type: String

implementation:
  container:
    image: gurpreetgandhi/nesy-factory:v34
    command:
      - sh
      - -c
      - |
        python3 -m pip install --quiet --upgrade pip setuptools wheel
        python3 -m pip install --quiet "torchvision==0.17.0"
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import torch
        import argparse, pickle, os, json, sys, time, io, traceback
        from torch.utils.data import TensorDataset, DataLoader
        from nesy_factory.CNNs import CNNFactory
        
        # Define the LabeledDataset and CustomJSONDataset classes for unpickling
        class LabeledDataset:
            def __init__(self, *args, **kwargs):
                obj = None
                if "dataset" in kwargs:
                    obj = kwargs["dataset"]
                elif len(args) == 1:
                    obj = args[0]
                else:
                    obj = kwargs

                self.dataset = getattr(obj, "dataset", None) or \
                               getattr(obj, "data", None) or \
                               getattr(obj, "samples", None) or \
                               obj

            def __len__(self):
                try:
                    return len(self.dataset)
                except:
                    return 100

            def __getitem__(self, idx):
                try:
                    item = self.dataset[idx]
                    if isinstance(item, tuple) and len(item) == 2:
                        return item
                    if isinstance(item, dict):
                        return item.get("image_data"), item.get("label", 0)
                except:
                    pass
                return torch.randn(3,224,224), 0
        
        class CustomJSONDataset(LabeledDataset):
            def __init__(self, *args, **kwargs):
                super().__init__(*args, **kwargs)

        class DataWrapper:
            def __init__(self, d=None):
                if d:
                    self.__dict__.update(d)

        # Safe unpickler
        class SafeUnpickler(pickle.Unpickler):
            def find_class(self, module, name):
                if name == "LabeledDataset":
                    return LabeledDataset
                if name == "CustomJSONDataset":
                    return CustomJSONDataset
                if name == "DataWrapper":
                    return DataWrapper
                return super().find_class(module, name)

        # Dataset loading helper
        def extract_tensors(loader):
            X, y = [], []
            for bx, by in loader:
                X.append(bx)
                y.append(by)
            return torch.cat(X), torch.cat(y)

        # Standard backpropagation training
        def train_backpropagation(model, X_train, y_train, X_val=None, y_val=None, 
                                  learning_rate=0.001, epochs=50, batch_size=32, verbose=True):
            device = next(model.parameters()).device
            
            # Create data loaders
            train_dataset = TensorDataset(X_train, y_train)
            train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
            
            # Setup optimizer and criterion
            optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)
            criterion = torch.nn.CrossEntropyLoss()
            
            # Training metrics
            train_losses = []
            val_losses = []
            
            # Training loop
            for epoch in range(epochs):
                model.train()
                epoch_loss = 0.0
                
                for batch_X, batch_y in train_loader:
                    batch_X, batch_y = batch_X.to(device), batch_y.to(device)
                    optimizer.zero_grad()
                    
                    outputs = model(batch_X)
                    loss = criterion(outputs, batch_y)
                    loss.backward()
                    optimizer.step()
                    
                    epoch_loss += loss.item()
                
                avg_train_loss = epoch_loss / len(train_loader)
                train_losses.append(avg_train_loss)
                
                # Validation
                if X_val is not None and y_val is not None:
                    model.eval()
                    val_dataset = TensorDataset(X_val, y_val)
                    val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)
                    
                    val_loss = 0.0
                    for batch_X, batch_y in val_loader:
                        batch_X, batch_y = batch_X.to(device), batch_y.to(device)
                        outputs = model(batch_X)
                        loss = criterion(outputs, batch_y)
                        val_loss += loss.item()
                    
                    avg_val_loss = val_loss / len(val_loader)
                    val_losses.append(avg_val_loss)

                if verbose and epoch % 10 == 0:
                    val_info = f", Val Loss: {val_losses[-1]:.4f}" if val_losses else ""
                    print(f"Epoch [{epoch+1}/{epochs}], Train Loss: {avg_train_loss:.4f}{val_info}")
            
            return {
                "train_losses": train_losses,
                "val_losses": val_losses if val_losses else None,
                "total_epochs": epochs
            }

        # History processing functions
        def flatten_forward_forward_history(history, max_rows=5):
            rows = []
            epoch = 0

            if "results" in history and "block_results" in history["results"]:
                block_results = history["results"]["block_results"]
                
                for block_idx, block in enumerate(block_results):
                    losses = block.get("epoch_losses", [])
                    for loss_idx, loss in enumerate(losses):
                        rows.append({
                            "epoch": epoch,
                            "loss": float(loss)
                        })
                        epoch += 1
            
            return rows[:max_rows]

        def flatten_cafo_history(history, max_rows=5):
            rows = []
            epoch = 0

            if "results" in history and "block_results" in history["results"]:
                block_results = history["results"]["block_results"]
                
                for block_idx, block in enumerate(block_results):
                    train_losses = block.get("train_losses", [])
                    
                    for loss_idx in range(len(train_losses)):
                        rows.append({
                            "epoch": epoch,
                            "loss": float(train_losses[loss_idx]) if loss_idx < len(train_losses) else None
                        })
                        epoch += 1
            
            return rows[:max_rows]

        def flatten_backprop_history(history, max_rows=5):
            rows = []
            
            if "results" in history:
                results = history["results"]
                train_losses = results.get("train_losses", [])
                val_losses = results.get("val_losses", [])
                
                for epoch_idx in range(len(train_losses)):
                    row = {
                        "epoch": epoch_idx + 1,
                        "loss": float(train_losses[epoch_idx]) if epoch_idx < len(train_losses) else None
                    }
                    
                    # Add validation loss if available
                    if epoch_idx < len(val_losses):
                        row["validation_loss"] = float(val_losses[epoch_idx])
                    
                    rows.append(row)
            
            return rows[:max_rows]

        def process_training_history(history, max_rows=5):
            training_mode = history.get("training_mode", "").lower()
            
            if "forward" in training_mode or "ff" in training_mode:
                return flatten_forward_forward_history(history, max_rows)
            elif "cafo" in training_mode:
                return flatten_cafo_history(history, max_rows)
            else:
                return flatten_backprop_history(history, max_rows)

        # ===========================================
        # PATCHED RESNET CLASS TO FIX DROPOUT ISSUE
        # ===========================================
        def create_patched_resnet_class():
           
            try:
                from nesy_factory.CNNs.ffresnet import ResNet as OriginalResNet
                from nesy_factory.CNNs.ffresnet import ForwardForwardResNetBlock, CaFoResNetBlock
                
                class PatchedResNet(OriginalResNet):
                    def __init__(self, config):
                        # Set dropout attribute BEFORE calling parent init
                        self.dropout = config.get('dropout', 0.0)
                        
                        # Call parent __init__ with error handling
                        try:
                            super().__init__(config)
                        except AttributeError as e:
                            if "'ResNet' object has no attribute 'dropout'" in str(e):
                                # Parent tried to access dropout before it was set
                                # Continue with initialization manually
                                self._complete_init_after_dropout_error(config)
                            else:
                                raise
                    
                    def _complete_init_after_dropout_error(self, config):
                      
                        # Set basic attributes
                        self.variant = config.get('variant', 'resnet50')
                        self.pretrained = config.get('pretrained', True)
                        self.input_channels = config.get('input_channels', 3)
                        self.output_dim = config['output_dim']
                        self.device = torch.device(config.get('device', 'cuda' if torch.cuda.is_available() else 'cpu'))
                        
                        # Training mode flags
                        self.use_cafo = config.get('use_cafo', False)
                        self.use_forward_forward = config.get('use_forward_forward', False)
                        
                        # Initialize as nn.Module
                        torch.nn.Module.__init__(self)
                        
                        # Set criterion
                        self.criterion = torch.nn.CrossEntropyLoss()
                        
                        # Create blocks based on training mode
                        if self.use_cafo:
                            self.cafo_blocks = config.get('cafo_blocks', 4)
                            self.epochs_per_block = config.get('epochs_per_block', 50)
                            self.block_lr = config.get('block_lr', 0.001)
                            self.blocks = torch.nn.ModuleList()
                            self._create_cafo_blocks()
                            self.cafo_trained = False
                            
                        elif self.use_forward_forward:
                            self.ff_blocks = config.get('ff_blocks', 4)
                            self.ff_epochs_per_block = config.get('ff_epochs_per_block', 50)
                            self.ff_lr = config.get('ff_lr', 0.01)
                            self.ff_threshold = config.get('ff_threshold', 2.0)
                            self.ff_goodness_dim = config.get('ff_goodness_dim', 128)
                            self.ff_blocks_list = torch.nn.ModuleList()
                            self._create_ff_blocks()
                            self.ff_trained = False
                            self.ff_classifier = None
                            
                        else:
                            # Standard ResNet
                            self._build_layers()
                        
                        # Move to device
                        self.to(self.device)
                    
                    def _create_ff_blocks(self):
                  
                        if self.variant in ['resnet18', 'resnet34']:
                            channel_configs = [(64, 64), (64, 128), (128, 256), (256, 512)]
                            strides = [1, 2, 2, 2]
                        else:  # ResNet50+
                            channel_configs = [(64, 256), (256, 512), (512, 1024), (1024, 2048)]
                            strides = [1, 2, 2, 2]

                        for i in range(min(self.ff_blocks, len(channel_configs))):
                            in_channels, out_channels = channel_configs[i]
                            stride = strides[i]
                            if i == 0:
                                in_channels = self.input_channels

                            block = ForwardForwardResNetBlock(
                                in_channels=in_channels,
                                out_channels=out_channels,
                                stride=stride,
                                dropout=self.dropout,
                                goodness_dim=self.ff_goodness_dim
                            )
                            self.ff_blocks_list.append(block)
                    
                    def _create_cafo_blocks(self):
                 
                        if self.variant in ['resnet18', 'resnet34']:
                            channel_configs = [(64, 64), (64, 128), (128, 256), (256, 512)]
                            strides = [1, 2, 2, 2]
                        else:  # ResNet50+
                            channel_configs = [(64, 256), (256, 512), (512, 1024), (1024, 2048)]
                            strides = [1, 2, 2, 2]
                        
                        for i in range(min(self.cafo_blocks, len(channel_configs))):
                            in_channels, out_channels = channel_configs[i]
                            stride = strides[i]
                            if i == 0:
                                in_channels = self.input_channels
                            
                            block = CaFoResNetBlock(
                                in_channels=in_channels,
                                out_channels=out_channels,
                                stride=stride,
                                output_dim=self.output_dim,
                                dropout=self.dropout
                            )
                            self.blocks.append(block)
                    
                    def _build_layers(self):
                    
                        # This is a simplified version for standard ResNet
                        from torchvision import models
                        
                        variant_map = {
                            'resnet18': models.resnet18,
                            'resnet34': models.resnet34,
                            'resnet50': models.resnet50,
                            'resnet101': models.resnet101,
                            'resnet152': models.resnet152
                        }
                        
                        if self.variant in variant_map:
                            resnet_model = variant_map[self.variant](pretrained=self.pretrained)
                            in_features = resnet_model.fc.in_features
                            resnet_model.fc = torch.nn.Linear(in_features, self.output_dim)
                            self.model = resnet_model
                        else:
                            # Fallback to creating a simple CNN
                            print(f"Warning: Variant {self.variant} not found, using simple CNN")
                            self.model = torch.nn.Sequential(
                                torch.nn.Conv2d(self.input_channels, 64, kernel_size=3, padding=1),
                                torch.nn.ReLU(),
                                torch.nn.MaxPool2d(2),
                                torch.nn.Conv2d(64, 128, kernel_size=3, padding=1),
                                torch.nn.ReLU(),
                                torch.nn.MaxPool2d(2),
                                torch.nn.Flatten(),
                                torch.nn.Linear(128 * 56 * 56, 512),
                                torch.nn.ReLU(),
                                torch.nn.Linear(512, self.output_dim)
                            )
                    
                    def forward(self, x):
                   
                        if self.use_cafo:
                            if not getattr(self, "cafo_trained", False):
                                raise RuntimeError("CAFO model must be trained using train_cafo() before inference")
                            return self._forward_cafo(x)
                        elif self.use_forward_forward:
                            if not getattr(self, "ff_trained", False):
                                raise RuntimeError("FF model must be trained using train_forward_forward() before inference")
                            return self._forward_ff(x)
                        else:
                            if hasattr(self, 'model'):
                                return self.model(x)
                            else:
                                # Fallback forward
                                return torch.zeros(x.shape[0], self.output_dim).to(self.device)
                    
                    def _forward_cafo(self, x):
                      
                        current_input = x
                        for i, block in enumerate(self.blocks):
                            features = block.forward(current_input)
                            if i == len(self.blocks) - 1:
                                return block.predict_local(features)
                            else:
                                current_input = features
                        return current_input
                    
                    def _forward_ff(self, x):
                        
                        current = x
                        for block in self.ff_blocks_list:
                            current = block.forward(current)
                        pooled = torch.nn.functional.adaptive_avg_pool2d(current, (1, 1))
                        pooled = torch.flatten(pooled, 1)
                        if self.ff_classifier is None:
                            # Create classifier if needed
                            in_features = pooled.shape[1]
                            self.ff_classifier = torch.nn.Linear(in_features, self.output_dim).to(self.device)
                        logits = self.ff_classifier(pooled)
                        return logits
                    
                    def get_num_parameters(self):
                        
                        return sum(p.numel() for p in self.parameters())
                    
                    def get_model_info(self):
                
                        return {
                            'model_class': self.__class__.__name__,
                            'variant': self.variant,
                            'input_channels': self.input_channels,
                            'output_dim': self.output_dim,
                            'use_cafo': self.use_cafo,
                            'use_forward_forward': self.use_forward_forward,
                            'num_parameters': self.get_num_parameters()
                        }
                
                return PatchedResNet
                
            except ImportError as e:
                print(f"Warning: Could not import Enhanced ResNet: {e}")
                return None

        # Parse arguments
        parser = argparse.ArgumentParser()
        parser.add_argument("--data_path", required=True)
        parser.add_argument("--config", required=True)
        parser.add_argument("--model_input", required=False)
        parser.add_argument("--mapping_json", required=False, default="{}")
        parser.add_argument("--max_history_rows", type=int, default=5)
        parser.add_argument("--trained_model", required=True)
        parser.add_argument("--training_history", required=True)
        parser.add_argument("--processed_history_json", required=True)
        args = parser.parse_args()

        # Load dataset
        print("Loading dataset...")
        with open(args.data_path, "rb") as f:
            processed = SafeUnpickler(io.BytesIO(f.read())).load()

        # Extract data
        train_loader = processed.train_loader
        test_loader = getattr(processed, "test_loader", None)
        num_classes = processed.num_classes

        X_train, y_train = extract_tensors(train_loader)
        X_val, y_val = (extract_tensors(test_loader) if test_loader else (None, None))

        # Load and parse config
        print("Loading configuration...")
        cfg = json.loads(args.config)
        model_cfg = cfg.get("model", {})
        training_cfg = cfg.get("training", {})
        
        # Extract training mode flags
        use_cafo = model_cfg.get("use_cafo", False)
        use_forward_forward = model_cfg.get("use_forward_forward", False)
        
        # Validate: can't use both CAFO and FF
        if use_cafo and use_forward_forward:
            raise ValueError("Cannot use both CAFO and Forward-Forward. Set one to false in config.")
        
        # Determine training mode
        if use_cafo:
            training_mode = "CAFO"
        elif use_forward_forward:
            training_mode = "Forward-Forward"
        else:
            training_mode = "Backpropagation"
        
        print(f"Training mode: {training_mode}")

        # Build config for model
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        
        # Start with base config
        model_config = {}
        
        # Copy model configuration
        model_config['input_channels'] = model_cfg.get('input_channels', 3)
        model_config['variant'] = model_cfg.get('variant', 'resnet50')
        model_config['pretrained'] = model_cfg.get('pretrained', True)
        model_config['dropout'] = model_cfg.get('dropout', 0.0)  # Include dropout
        
        # Set output dimension
        model_config['output_dim'] = num_classes
        
        # Device
        model_config['device'] = str(device)
        
        # Training mode flags
        model_config['use_cafo'] = use_cafo
        model_config['use_forward_forward'] = use_forward_forward
        
        # Training params (for backpropagation)
        if training_mode == "Backpropagation":
            optimizer_cfg = training_cfg.get("optimizer", {})
            model_config['learning_rate'] = optimizer_cfg.get('learning_rate', 0.001)
            model_config['epochs'] = training_cfg.get('epochs', 50)
            model_config['batch_size'] = training_cfg.get('batch_size', 32)
        
        # Add CAFO-specific params if CAFO mode
        if use_cafo:
            model_config['cafo_blocks'] = model_cfg.get('cafo_blocks', 4)
            model_config['epochs_per_block'] = model_cfg.get('epochs_per_block', 50)
            model_config['block_lr'] = model_cfg.get('block_lr', 0.001)
        
        # Add Forward-Forward params if FF mode
        if use_forward_forward:
            ff_cfg = model_cfg.get("forward_forward", {})
            model_config['ff_blocks'] = ff_cfg.get('ff_blocks', 4)
            model_config['ff_epochs_per_block'] = ff_cfg.get('ff_epochs_per_block', 50)
            model_config['ff_lr'] = ff_cfg.get('ff_lr', 0.01)
            model_config['ff_threshold'] = ff_cfg.get('threshold', 2.0)
            model_config['ff_goodness_dim'] = ff_cfg.get('ff_goodness_dim', 128)

        # Print config
        print(f"\\nConfiguration:")
        print(f"  Variant: {model_config.get('variant', 'resnet50')}")
        print(f"  Output dim: {model_config.get('output_dim')}")
        print(f"  Dropout: {model_config.get('dropout', 0.0)}")
        print(f"  Training mode: {training_mode}")

        # Create or load model
        net = None
        model_source = "freshly_created"
        
        # Get the patched ResNet class
        PatchedResNet = create_patched_resnet_class()
        
        if args.model_input and os.path.exists(args.model_input):
            # Load existing model
            print(f"\\nLoading model from: {args.model_input}")
            try:
                # Load the checkpoint
                checkpoint = torch.load(args.model_input, map_location='cpu')
                
                # Check if it's a full checkpoint
                if isinstance(checkpoint, dict) and 'config' in checkpoint:
                    print("Loading full checkpoint with config...")
                    checkpoint_config = checkpoint.get('config', {})
                    
                    # Update model_config with checkpoint config
                    for key, value in checkpoint_config.items():
                        if key not in model_config:
                            model_config[key] = value
                    
                    # Determine which ResNet class to use
                    if use_cafo or use_forward_forward:
                        print(f"Creating Enhanced ResNet for {training_mode} training...")
                        
                        if PatchedResNet is not None:
                            net = PatchedResNet(model_config)
                            print("✓ Created Patched ResNet")
                        else:
                            print("Warning: PatchedResNet not available, using standard ResNet")
                            model_config['use_cafo'] = False
                            model_config['use_forward_forward'] = False
                            net = CNNFactory.create_model('resnet', model_config)
                    else:
                        print("Creating standard ResNet for backpropagation...")
                        net = CNNFactory.create_model('resnet', model_config)
                    
                    # Load state dict
                    state_dict = checkpoint.get('model_state_dict', checkpoint)
                    try:
                        net.load_state_dict(state_dict, strict=False)
                        print("✓ Loaded model weights (strict=False)")
                        model_source = "loaded_checkpoint"
                    except Exception as e:
                        print(f"Warning: Could not load weights: {e}")
                        print("Creating fresh model instead...")
                        if use_cafo or use_forward_forward and PatchedResNet is not None:
                            net = PatchedResNet(model_config)
                        else:
                            model_config['use_cafo'] = False
                            model_config['use_forward_forward'] = False
                            net = CNNFactory.create_model('resnet', model_config)
                        model_source = "fresh_after_failed_load"
                        
                else:
                    # Just state dict
                    print("Loading model state dict...")
                    
                    if use_cafo or use_forward_forward and PatchedResNet is not None:
                        net = PatchedResNet(model_config)
                    else:
                        model_config['use_cafo'] = False
                        model_config['use_forward_forward'] = False
                        net = CNNFactory.create_model('resnet', model_config)
                    
                    try:
                        net.load_state_dict(checkpoint, strict=False)
                        print("✓ Successfully loaded model weights (strict=False)")
                        model_source = "loaded_state_dict"
                    except Exception as e:
                        print(f"Warning: Could not load weights: {e}")
                        if use_cafo or use_forward_forward and PatchedResNet is not None:
                            net = PatchedResNet(model_config)
                        else:
                            model_config['use_cafo'] = False
                            model_config['use_forward_forward'] = False
                            net = CNNFactory.create_model('resnet', model_config)
                        model_source = "fresh_after_failed_load"
                    
            except Exception as e:
                print(f"Error loading model: {e}")
                print("Creating fresh model instead...")
                if use_cafo or use_forward_forward and PatchedResNet is not None:
                    net = PatchedResNet(model_config)
                else:
                    model_config['use_cafo'] = False
                    model_config['use_forward_forward'] = False
                    net = CNNFactory.create_model('resnet', model_config)
                model_source = "fresh_after_failed_load"
        else:
            # Create fresh model
            print("\\nNo model input provided, creating fresh model...")
            if use_cafo or use_forward_forward:
                if PatchedResNet is not None:
                    print(f"Creating Patched ResNet for {training_mode} training...")
                    net = PatchedResNet(model_config)
                else:
                    print(f"Warning: PatchedResNet not available")
                    print("Falling back to standard ResNet (CAFO/FF training won't work)")
                    model_config['use_cafo'] = False
                    model_config['use_forward_forward'] = False
                    net = CNNFactory.create_model('resnet', model_config)
            else:
                print("Creating standard ResNet for backpropagation...")
                net = CNNFactory.create_model('resnet', model_config)
            model_source = "fresh_no_input"

        net = net.to(device)
        print(f"Model created with {net.get_num_parameters() if hasattr(net, 'get_num_parameters') else sum(p.numel() for p in net.parameters())} parameters")
        print(f"Model source: {model_source}")

        # Train based on mode
        print(f"\\nStarting {training_mode} training...")
        
        if use_cafo:
            # Use nesyfactory's CAFO training method
            if hasattr(net, 'train_cafo'):
                results = net.train_cafo(
                    X_train.to(device),
                    y_train.to(device),
                    X_val.to(device) if X_val is not None else None,
                    y_val.to(device) if y_val is not None else None,
                    verbose=True
                )
                model_trained_flag = {"cafo_trained": True}
            else:
                print("Warning: Model doesn't have train_cafo method, using backpropagation")
                learning_rate = model_config.get('learning_rate', 0.001)
                epochs = model_config.get('epochs', 50)
                batch_size = model_config.get('batch_size', 32)
                results = train_backpropagation(
                    net,
                    X_train.to(device),
                    y_train.to(device),
                    X_val.to(device) if X_val is not None else None,
                    y_val.to(device) if y_val is not None else None,
                    learning_rate=learning_rate,
                    epochs=epochs,
                    batch_size=batch_size,
                    verbose=True
                )
                model_trained_flag = {"backprop_trained": True}
                
        elif use_forward_forward:
            # Use nesyfactory's Forward-Forward training method
            if hasattr(net, 'train_forward_forward'):
                results = net.train_forward_forward(
                    X_train.to(device),
                    y_train.to(device),
                    X_val.to(device) if X_val is not None else None,
                    y_val.to(device) if y_val is not None else None,
                    verbose=True
                )
                model_trained_flag = {"ff_trained": True}
            else:
                print("Warning: Model doesn't have train_forward_forward method, using backpropagation")
                learning_rate = model_config.get('learning_rate', 0.001)
                epochs = model_config.get('epochs', 50)
                batch_size = model_config.get('batch_size', 32)
                results = train_backpropagation(
                    net,
                    X_train.to(device),
                    y_train.to(device),
                    X_val.to(device) if X_val is not None else None,
                    y_val.to(device) if y_val is not None else None,
                    learning_rate=learning_rate,
                    epochs=epochs,
                    batch_size=batch_size,
                    verbose=True
                )
                model_trained_flag = {"backprop_trained": True}
            
        else:
            # Standard backpropagation
            learning_rate = model_config.get('learning_rate', 0.001)
            epochs = model_config.get('epochs', 50)
            batch_size = model_config.get('batch_size', 32)
            
            results = train_backpropagation(
                net,
                X_train.to(device),
                y_train.to(device),
                X_val.to(device) if X_val is not None else None,
                y_val.to(device) if y_val is not None else None,
                learning_rate=learning_rate,
                epochs=epochs,
                batch_size=batch_size,
                verbose=True
            )
            model_trained_flag = {"backprop_trained": True}

        # Save model & history
        print("\\nSaving model and training history...")
        os.makedirs(os.path.dirname(args.trained_model), exist_ok=True)
        os.makedirs(os.path.dirname(args.training_history), exist_ok=True)
        os.makedirs(os.path.dirname(args.processed_history_json), exist_ok=True)

        # Save model checkpoint
        checkpoint = {
            'model_state_dict': net.state_dict(),
            'config': model_config,
            'training_mode': training_mode,
            'model_source': model_source,
            'num_classes': num_classes
        }
        torch.save(checkpoint, args.trained_model)

        # Save full training history
        history = {
            "training_mode": training_mode,
            "results": results,
            "config": model_config,
            "model_source": model_source,
            "num_classes": num_classes
        }
        with open(args.training_history, "w") as f:
            json.dump(history, f, indent=2)

        # Process training history into flattened format
        print("\\nProcessing training history...")
        processed_rows = process_training_history(history, args.max_history_rows)

        print(f"\\nDEBUG: Processed {len(processed_rows)} history rows")
        for i, row in enumerate(processed_rows):
            print(f"  Row {i}: {row}")

        # Create output compatible with Update Schema Row AND ProcessHistory
        if processed_rows and len(processed_rows) > 0:
            # Use last row (most recent training results)
            last_row = processed_rows[-1]
            
            # Create combined output
            output = {
                # Flat fields for Update Schema Row (using last row)
                "epoch": int(last_row.get("epoch", len(processed_rows))),
                "loss": float(last_row.get("loss", 0.0))
            }
            
            # Add validation_loss if available
            if "validation_loss" in last_row:
                output["validation_loss"] = float(last_row.get("validation_loss", 0.0))
            elif "val_loss" in last_row:
                output["validation_loss"] = float(last_row.get("val_loss", 0.0))
            
            # Add accuracy fields if available
            if "accuracy" in last_row:
                output["accuracy"] = float(last_row.get("accuracy", 0.0))
            
            if "validation_accuracy" in last_row:
                output["validation_accuracy"] = float(last_row.get("validation_accuracy", 0.0))
            
            # Include the full array for ProcessHistory compatibility
            output["data"] = processed_rows
            
        else:
            # No training history available
            output = {
                "epoch": 0,
                "loss": 0.0,
                "validation_loss": 0.0,
                "accuracy": 0.0,
                "validation_accuracy": 0.0,
                "data": []
            }

        print(f"\\nFinal output format:")
        print(f"  Flat fields: { {k: v for k, v in output.items() if k != 'data'} }")
        print(f"  Array data: {len(output.get('data', []))} rows")

        # Save the output
        with open(args.processed_history_json, "w") as f:
            json.dump(output, f, indent=2)

        print(f"\\n✓ {training_mode} training completed successfully!")
        print(f"✓ Model saved to: {args.trained_model}")
        print(f"✓ Full history saved to: {args.training_history}")
        print(f"✓ Processed history saved to: {args.processed_history_json}")
        print(f"✓ Processed {len(processed_rows)} history rows")
        
    args:
      - --data_path
      - {inputPath: data_path}
      - --config
      - {inputValue: config}
      - --model_input
      - {inputPath: model_input}
      - --mapping_json
      - {inputValue: mapping_json}
      - --max_history_rows
      - {inputValue: max_history_rows}
      - --trained_model
      - {outputPath: trained_model}
      - --training_history
      - {outputPath: training_history}
      - --processed_history_json
      - {outputPath: processed_history_json}
