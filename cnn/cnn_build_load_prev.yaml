name: Build or Load Model v13
description: Builds CNN model using nesyfactory with dropout fix and schema support
inputs:
  - name: config_str
    type: String
  - name: model_name
    type: String
  - name: load_from_cdn
    type: String
    default: "false"
  - name: cdn_url
    type: String
  - name: load_from_schema
    type: String
    default: "false"
  - name: schema_id
    type: String
  - name: bearer_token
    type: String
  - name: model_id
    type: String
  - name: execution_id
    type: String
outputs:
  - name: model_out
    type: Model
  - name: config_updated
    type: String
  - name: model_info_out
    type: String

implementation:
  container:
    image: nikhilv215/nesy-factory:v23
    command:
      - sh
      - -c
      - |
        python3 -m pip install --quiet --upgrade pip setuptools wheel
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import torch, argparse, json, os, sys, tempfile
        import urllib.request
        import requests
        from nesy_factory.CNNs.factory import CNNFactory
        from nesy_factory.CNNs.ffresnet import ResNet
        
        parser = argparse.ArgumentParser()
        parser.add_argument('--config_str', type=str, default='')
        parser.add_argument('--model_name', type=str, default='')
        parser.add_argument('--load_from_cdn', type=str, default='false')
        parser.add_argument('--cdn_url', type=str, default='')
        parser.add_argument('--load_from_schema', type=str, default='false')
        parser.add_argument('--schema_id', type=str, default='')
        parser.add_argument('--bearer_token', type=str, default='')
        parser.add_argument('--model_id', type=str, default='')
        parser.add_argument('--execution_id', type=str, default='')
        parser.add_argument('--model_out', type=str, required=True)
        parser.add_argument('--config_updated', type=str, required=True)
        parser.add_argument('--model_info_out', type=str, required=True)
        args = parser.parse_args()
        
        load_from_cdn = args.load_from_cdn.lower() == 'true'
        load_from_schema = args.load_from_schema.lower() == 'true'
        
        # Create output directories
        os.makedirs(os.path.dirname(args.model_out), exist_ok=True)
        os.makedirs(os.path.dirname(args.config_updated), exist_ok=True)
        os.makedirs(os.path.dirname(args.model_info_out), exist_ok=True)
        
        # ===========================================
        # FIXED RESNET CLASS WITH CRITERION FIX
        # ===========================================
        class FixedResNet(ResNet):
            def __init__(self, config):
                # CRITICAL: Set dropout attribute BEFORE calling parent init
                self.dropout = config.get('dropout', 0.0)
                # Now call parent init
                super().__init__(config)
                # Ensure criterion exists (for consistency across bricks)
                if not hasattr(self, 'criterion') or self.criterion is None:
                    self.criterion = torch.nn.CrossEntropyLoss()
        
        def build_model_from_config(config_dict):
            """Build a model from configuration dictionary"""
            try:
                print(f"Building model with config: {json.dumps(config_dict, indent=2)}")
                
                # Set default values
                defaults = {
                    'variant': 'resnet50',
                    'output_dim': 10,
                    'input_channels': 3,
                    'pretrained': False,  # False when loading weights
                    'dropout': 0.0,
                    'use_cafo': False,
                    'use_forward_forward': False,
                    'device': 'cpu'
                }
                
                for param, default_value in defaults.items():
                    if param not in config_dict:
                        config_dict[param] = default_value
                
                # Determine training mode
                use_cafo = config_dict.get('use_cafo', False)
                use_forward_forward = config_dict.get('use_forward_forward', False)
                
                print(f"\\n=== Model Configuration ===")
                print(f"Architecture: ResNet")
                print(f"Training Mode: {'CAFO' if use_cafo else 'Forward-Forward' if use_forward_forward else 'Standard Backprop'}")
                print(f"Variant: {config_dict.get('variant', 'resnet50')}")
                print(f"Output dim: {config_dict['output_dim']}")
                print(f"Dropout: {config_dict.get('dropout', 0.0)}")
                
                # Create the model using FixedResNet
                print(f"\\nCreating model using FixedResNet...")
                model = FixedResNet(config_dict)
                
                print(f"✓ Model created successfully")
                print(f"✓ Parameters: {sum(p.numel() for p in model.parameters()):,}")
                
                return model, config_dict
                
            except Exception as e:
                print(f"\\n ERROR: Failed to create model: {e}")
                import traceback
                traceback.print_exc()
                return None, None
        
        def load_weights_and_build_model(weights_url, config, source_info):
            """Download weights and load them into a model"""
            try:
                print(f"Loading model weights from: {weights_url}")
                
                # Download weights
                with tempfile.NamedTemporaryFile(delete=False, suffix='.pth') as tmp_file:
                    tmp_path = tmp_file.name
                
                print(f"Downloading weights...")
                urllib.request.urlretrieve(weights_url, tmp_path)
                print("Download completed")
                
                # Load checkpoint
                checkpoint = torch.load(tmp_path, map_location='cpu')
                print(f"Checkpoint type: {type(checkpoint)}")
                print(f"Checkpoint keys: {checkpoint.keys() if isinstance(checkpoint, dict) else 'Not a dict'}")
                
                # Extract model config from checkpoint if available
                if isinstance(checkpoint, dict):
                    if 'config' in checkpoint:
                        # Use config from checkpoint (most accurate)
                        model_config = checkpoint['config']
                        print("Using config from checkpoint")
                    elif 'model_info' in checkpoint:
                        # Try to extract from model_info
                        model_info = checkpoint['model_info']
                        model_config = {
                            'variant': model_info.get('variant', 'resnet50'),
                            'output_dim': model_info.get('output_dim', 10),
                            'use_cafo': model_info.get('use_cafo', False),
                            'use_forward_forward': model_info.get('use_forward_forward', False),
                            'dropout': model_info.get('dropout', 0.0)
                        }
                        print("Using config from model_info")
                    else:
                        # Use provided config
                        model_config = config.get('model', {})
                        print("Using provided config")
                else:
                    model_config = config.get('model', {})
                    print("Using provided config (checkpoint is not dict)")
                
                # Ensure architecture is set
                model_config['architecture'] = args.model_name if args.model_name else 'ResNet'
                
                # Build model
                model, final_config = build_model_from_config(model_config)
                if model is None:
                    raise Exception("Failed to build model from config")
                
                # Load weights
                if isinstance(checkpoint, dict):
                    if 'model_state_dict' in checkpoint:
                        model.load_state_dict(checkpoint['model_state_dict'])
                        print("Loaded model_state_dict from checkpoint")
                    elif 'state_dict' in checkpoint:
                        model.load_state_dict(checkpoint['state_dict'])
                        print("Loaded state_dict from checkpoint")
                    else:
                        # Assume checkpoint is the state dict itself
                        model.load_state_dict(checkpoint)
                        print("Loaded checkpoint as state_dict")
                else:
                    # Assume checkpoint is the state dict
                    model.load_state_dict(checkpoint)
                    print("Loaded checkpoint directly as state_dict")
                
                print(f"✓ Weights loaded successfully")
                
                # Prepare output config
                output_config = config.copy()
                output_config['model'] = final_config
                output_config['model_source'] = source_info['source']
                output_config.update(source_info.get('extra_config', {}))
                
                # Prepare model info
                model_info = {
                    'model_name': args.model_name,
                    'model_source': source_info['source'],
                    'weights_url': weights_url,
                    'variant': final_config.get('variant', 'resnet50'),
                    'output_dim': final_config.get('output_dim', 10),
                    'num_parameters': sum(p.numel() for p in model.parameters()),
                    'use_cafo': final_config.get('use_cafo', False),
                    'use_forward_forward': final_config.get('use_forward_forward', False),
                    'model_class': model.__class__.__name__
                }
                model_info.update(source_info.get('extra_info', {}))
                
                # Save model checkpoint
                save_checkpoint = {
                    'config': final_config,
                    'model_state_dict': model.state_dict(),
                    'model_info': model_info,
                    'training_mode': 'CAFO' if final_config.get('use_cafo') else 'Forward-Forward' if final_config.get('use_forward_forward') else 'Standard'
                }
                torch.save(save_checkpoint, args.model_out)
                
                # Save config
                with open(args.config_updated, 'w') as f:
                    json.dump(output_config, f, indent=2)
                
                # Save model info
                with open(args.model_info_out, 'w') as f:
                    json.dump(model_info, f, indent=2)
                
                os.unlink(tmp_path)
                print(f"\\n✓ Model loaded and saved to: {args.model_out}")
                
                return True
                
            except Exception as e:
                print(f"\\n ERROR: Failed to load weights: {e}")
                import traceback
                traceback.print_exc()
                if 'tmp_path' in locals():
                    try:
                        os.unlink(tmp_path)
                    except:
                        pass
                return False
        
        # Main logic
        if load_from_schema:
            # MODE 3: Load model from schema
            if not all([args.schema_id, args.bearer_token, args.model_id, args.execution_id]):
                print("ERROR: schema_id, bearer_token, model_id, and execution_id are required when load_from_schema=true")
                sys.exit(1)
            
            try:
                execution_id_int = int(args.execution_id)
            except ValueError:
                print(f"ERROR: execution_id must be an integer. Got: {args.execution_id}")
                sys.exit(1)
                
            print(f"Loading model from schema...")
            print(f"Schema ID: {args.schema_id}")
            print(f"Model ID: {args.model_id}")
            print(f"Execution ID: {execution_id_int}")
            
            # Parse config
            config = json.loads(args.config_str) if args.config_str else {}
            
            # API endpoint for schema
            schema_url = f"https://igs.gov-cloud.ai/pi-entity-instances-service/v3.0/schemas/{args.schema_id}/instances/list?size=1000"
            
            headers = {
                'Authorization': f'Bearer {args.bearer_token}',
                'Content-Type': 'application/json'
            }
            
            # Filter for model_id and execution_id
            filter_data = {
                "dbType": "TIDB",
                "ownedOnly": True,
                "filter": {
                    "model_id": args.model_id,
                    "execution_id": execution_id_int
                }
            }
            
            try:
                print(f"Fetching schema data from: {schema_url}")
                response = requests.post(schema_url, headers=headers, json=filter_data)
                response.raise_for_status()
                
                schema_data = response.json()
                print(f"Schema response status: {response.status_code}")
                
                # Extract model_weights_cdn from schema response
                if 'content' in schema_data and len(schema_data['content']) > 0:
                    instance = schema_data['content'][0]
                    model_weights_cdn = instance.get('model_weights_cdn')
                    
                    if not model_weights_cdn:
                        print("ERROR: model_weights_cdn not found in schema response")
                        print(f"Available fields: {list(instance.keys())}")
                        sys.exit(1)
                    
                    print(f"Found model_weights_cdn: {model_weights_cdn}")
                    
                    # Load weights and build model
                    source_info = {
                        'source': 'schema',
                        'extra_config': {
                            'schema_id': args.schema_id,
                            'model_id': args.model_id,
                            'execution_id': execution_id_int,
                            'cdn_url': model_weights_cdn
                        },
                        'extra_info': {
                            'schema_id': args.schema_id,
                            'model_id': args.model_id,
                            'execution_id': execution_id_int,
                            'schema_instance': instance
                        }
                    }
                    
                    success = load_weights_and_build_model(model_weights_cdn, config, source_info)
                    if not success:
                        sys.exit(1)
                    
                    print("✓ Successfully loaded model from schema")
                    
                else:
                    print("ERROR: No instances found in schema response")
                    print(f"Response: {json.dumps(schema_data, indent=2)}")
                    sys.exit(1)
                    
            except requests.exceptions.RequestException as e:
                print(f"ERROR: Failed to fetch schema data: {e}")
                if hasattr(e, 'response'):
                    print(f"Response content: {e.response.text}")
                sys.exit(1)
            except Exception as e:
                print(f"ERROR: Failed to load model from schema: {e}")
                import traceback
                traceback.print_exc()
                sys.exit(1)
                
        elif load_from_cdn:
            # MODE 1: Download model from CDN directly
            if not args.cdn_url:
                print("ERROR: cdn_url is required when load_from_cdn=true")
                sys.exit(1)
                
            print(f"Loading model from CDN: {args.cdn_url}")
            
            # Parse config
            config = json.loads(args.config_str) if args.config_str else {}
            
            # Load weights and build model
            source_info = {
                'source': 'cdn',
                'extra_config': {
                    'cdn_url': args.cdn_url
                },
                'extra_info': {
                    'cdn_url': args.cdn_url
                }
            }
            
            success = load_weights_and_build_model(args.cdn_url, config, source_info)
            if not success:
                sys.exit(1)
            
            print("✓ Successfully loaded model from CDN")
                
        else:
            # MODE 2: Build new model from configuration
            if not args.config_str or not args.model_name:
                print("ERROR: config_str and model_name are required when load_from_cdn=false and load_from_schema=false")
                sys.exit(1)
                
            config = json.loads(args.config_str)
            model_config = config.get('model', {})
            model_config['architecture'] = args.model_name
            
            # Build model from scratch
            model, final_config = build_model_from_config(model_config)
            if model is None:
                sys.exit(1)
            
            # Prepare output config
            output_config = config.copy()
            output_config['model'] = final_config
            output_config['model_source'] = 'fresh_build'
            
            # Prepare model info
            model_info = {
                'model_name': args.model_name,
                'model_source': 'fresh_build',
                'variant': final_config.get('variant', 'resnet50'),
                'input_channels': final_config.get('input_channels', 3),
                'output_dim': final_config['output_dim'],
                'num_parameters': sum(p.numel() for p in model.parameters()),
                'use_cafo': final_config.get('use_cafo', False),
                'use_forward_forward': final_config.get('use_forward_forward', False),
                'model_class': model.__class__.__name__
            }
            
            # Save model checkpoint
            save_checkpoint = {
                'config': final_config,
                'model_state_dict': model.state_dict(),
                'model_info': model_info,
                'training_mode': 'CAFO' if final_config.get('use_cafo') else 'Forward-Forward' if final_config.get('use_forward_forward') else 'Standard'
            }
            torch.save(save_checkpoint, args.model_out)

            # Save updated config
            with open(args.config_updated, 'w') as f:
                json.dump(output_config, f, indent=2)
                
            # Save model info
            with open(args.model_info_out, 'w') as f:
                json.dump(model_info, f, indent=2)

            print(f"\\n✓ Model built and saved to: {args.model_out}")
            print(f"✓ Model info saved to: {args.model_info_out}")
        
    args:
      - --model_name
      - {inputValue: model_name}
      - --config_str
      - {inputValue: config_str}
      - --load_from_cdn
      - {inputValue: load_from_cdn}
      - --cdn_url
      - {inputValue: cdn_url}
      - --load_from_schema
      - {inputValue: load_from_schema}
      - --schema_id
      - {inputValue: schema_id}
      - --bearer_token
      - {inputValue: bearer_token}
      - --model_id
      - {inputValue: model_id}
      - --execution_id
      - {inputValue: execution_id}
      - --model_out
      - {outputPath: model_out}
      - --config_updated
      - {outputPath: config_updated}
      - --model_info_out
      - {outputPath: model_info_out}
