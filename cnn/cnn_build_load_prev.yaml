name: Build or Load Model v11
description: Builds a CNN model with patched ResNet to fix dropout issue
inputs:
  - name: config_str
    type: String
  - name: model_name
    type: String
  - name: load_from_cdn
    type: String
    default: "false"
  - name: cdn_url
    type: String
outputs:
  - name: model_out
    type: Model
  - name: config_updated
    type: String
  - name: model_info_out
    type: String

implementation:
  container:
    image: gurpreetgandhi/nesy-factory:v34
    command:
      - sh
      - -c
      - |
        python3 -m pip install --quiet --upgrade pip setuptools wheel
        python3 -m pip install --quiet "torchvision==0.17.0"
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import torch, argparse, json, os, sys, tempfile
        import urllib.request
        from nesy_factory.CNNs.factory import CNNFactory
        
        parser = argparse.ArgumentParser()
        parser.add_argument('--config_str', type=str, default='')
        parser.add_argument('--model_name', type=str, default='')
        parser.add_argument('--load_from_cdn', type=str, default='false')
        parser.add_argument('--cdn_url', type=str, default='')
        parser.add_argument('--model_out', type=str, required=True)
        parser.add_argument('--config_updated', type=str, required=True)
        parser.add_argument('--model_info_out', type=str, required=True)
        args = parser.parse_args()
        
        load_from_cdn = args.load_from_cdn.lower() == 'true'
        
        # Create output directories
        os.makedirs(os.path.dirname(args.model_out), exist_ok=True)
        os.makedirs(os.path.dirname(args.config_updated), exist_ok=True)
        os.makedirs(os.path.dirname(args.model_info_out), exist_ok=True)
        
        if load_from_cdn:
            # MODE 1: Download model from CDN
            if not args.cdn_url:
                print("ERROR: cdn_url is required when load_from_cdn=true")
                sys.exit(1)
                
            print(f"Loading model from CDN: {args.cdn_url}")
            
            try:
                with tempfile.NamedTemporaryFile(delete=False, suffix='.pth') as tmp_file:
                    tmp_path = tmp_file.name
                
                print(f"Downloading from {args.cdn_url}...")
                urllib.request.urlretrieve(args.cdn_url, tmp_path)
                print("Download completed")
                
                checkpoint = torch.load(tmp_path, map_location='cpu')
                torch.save(checkpoint, args.model_out)
                print(f"Model loaded from CDN and saved to: {args.model_out}")
                
                if args.config_str:
                    config = json.loads(args.config_str)
                else:
                    config = {}
                
                config['model_source'] = 'cdn'
                config['cdn_url'] = args.cdn_url
                
                with open(args.config_updated, 'w') as f:
                    json.dump(config, f, indent=2)
                
                model_info = {
                    'model_source': 'cdn',
                    'cdn_url': args.cdn_url,
                    'checkpoint_type': 'full_model' if isinstance(checkpoint, dict) and 'model_state_dict' in checkpoint else 'state_dict'
                }
                with open(args.model_info_out, 'w') as f:
                    json.dump(model_info, f, indent=2)
                    
                os.unlink(tmp_path)
                
            except Exception as e:
                print(f"Failed to load model from CDN: {e}")
                sys.exit(1)
                
        else:
            # MODE 2: Build new model from configuration
            if not args.config_str or not args.model_name:
                print("ERROR: config_str and model_name are required when load_from_cdn=false")
                sys.exit(1)
                
            config = json.loads(args.config_str)
            model_config = config.get('model', {})
            model_config['architecture'] = args.model_name
            
            # Set default values
            defaults = {
                'output_dim': 10,
                'input_channels': 3,
                'input_size': [224, 224],
                'pretrained': True,
                'use_cafo': False,
                'use_forward_forward': False,
                'variant': 'resnet50',
                'dropout': 0.0  # IMPORTANT: Include dropout here
            }
            
            for param, default_value in defaults.items():
                if param not in model_config:
                    print(f"{param} not found, using default: {default_value}")
                    model_config[param] = default_value

            # CRITICAL: Check which ResNet architecture to create
            use_cafo = model_config.get('use_cafo', False)
            use_forward_forward = model_config.get('use_forward_forward', False)
            
            print(f"\\n=== Model Configuration ===")
            print(f"Architecture: {model_config['architecture']}")
            print(f"Training Mode: {'CAFO' if use_cafo else 'Forward-Forward' if use_forward_forward else 'Standard Backprop'}")
            print(f"Variant: {model_config.get('variant', 'resnet50')}")
            print(f"Output dim: {model_config['output_dim']}")
            print(f"Dropout: {model_config.get('dropout', 0.0)}")
            
            try:
                # ===========================================
                # CREATE PATCHED RESNET CLASS
                # ===========================================
                
                if use_cafo or use_forward_forward:
                    print(f"\\nCreating Enhanced ResNet (supports CAFO/Forward-Forward)...")
                    
                    try:
                        from nesy_factory.CNNs.ffresnet import ResNet as OriginalResNet
                        
                        # Create a patched version of ResNet
                        class PatchedResNet(OriginalResNet):
                            def __init__(self, config):
                                # Ensure dropout is set as an attribute BEFORE calling parent init
                                self.dropout = config.get('dropout', 0.0)
                                
                                # Call parent __init__
                                try:
                                    super().__init__(config)
                                except AttributeError as e:
                                    if "'ResNet' object has no attribute 'dropout'" in str(e):
                                        # If parent still complains, ensure dropout exists
                                        if not hasattr(self, 'dropout'):
                                            self.dropout = config.get('dropout', 0.0)
                                        # Try to continue initialization
                                        print("DEBUG: Caught dropout error, continuing...")
                                        # Set other required attributes
                                        if hasattr(self, '_create_ff_blocks'):
                                            self._create_ff_blocks()
                                        if hasattr(self, '_create_cafo_blocks'):
                                            self._create_cafo_blocks()
                                    else:
                                        raise
                            
                            def _create_ff_blocks(self):
                                
                                if self.variant in ['resnet18', 'resnet34']:
                                    channel_configs = [(64, 64), (64, 128), (128, 256), (256, 512)]
                                    strides = [1, 2, 2, 2]
                                else:  # ResNet50+
                                    channel_configs = [(64, 256), (256, 512), (512, 1024), (1024, 2048)]
                                    strides = [1, 2, 2, 2]

                                from nesy_factory.CNNs.ffresnet import ForwardForwardResNetBlock
                                
                                for i in range(min(self.ff_blocks, len(channel_configs))):
                                    in_channels, out_channels = channel_configs[i]
                                    stride = strides[i]
                                    if i == 0:
                                        in_channels = self.input_channels

                                    block = ForwardForwardResNetBlock(
                                        in_channels=in_channels,
                                        out_channels=out_channels,
                                        stride=stride,
                                        dropout=self.dropout,
                                        goodness_dim=self.ff_goodness_dim
                                    )
                                    self.ff_blocks_list.append(block)
                            
                            def _create_cafo_blocks(self):
                                
                                if self.variant in ['resnet18', 'resnet34']:
                                    channel_configs = [(64, 64), (64, 128), (128, 256), (256, 512)]
                                    strides = [1, 2, 2, 2]
                                else:  # ResNet50+
                                    channel_configs = [(64, 256), (256, 512), (512, 1024), (1024, 2048)]
                                    strides = [1, 2, 2, 2]
                                
                                from nesy_factory.CNNs.ffresnet import CaFoResNetBlock
                                
                                for i in range(min(self.cafo_blocks, len(channel_configs))):
                                    in_channels, out_channels = channel_configs[i]
                                    stride = strides[i]
                                    if i == 0:
                                        in_channels = self.input_channels
                                    
                                    block = CaFoResNetBlock(
                                        in_channels=in_channels,
                                        out_channels=out_channels,
                                        stride=stride,
                                        output_dim=self.output_dim,
                                        dropout=self.dropout
                                    )
                                    self.blocks.append(block)
                        
                        # Ensure required FF/CAFO params are in config
                        if use_cafo:
                            model_config['cafo_blocks'] = model_config.get('cafo_blocks', 4)
                            model_config['epochs_per_block'] = model_config.get('epochs_per_block', 50)
                            model_config['block_lr'] = model_config.get('block_lr', 0.001)
                        elif use_forward_forward:
                            ff_config = model_config.get("forward_forward", {})
                            model_config['ff_blocks'] = ff_config.get('ff_blocks', 4)
                            model_config['ff_epochs_per_block'] = ff_config.get('ff_epochs_per_block', 50)
                            model_config['ff_lr'] = ff_config.get('ff_lr', 0.01)
                            model_config['ff_threshold'] = ff_config.get('threshold', 2.0)
                            model_config['ff_goodness_dim'] = ff_config.get('ff_goodness_dim', 128)
                        
                        # Create the patched model
                        model = PatchedResNet(model_config)
                        print(f"✓ Created Patched ResNet for {training_mode}")
                        
                    except Exception as e:
                        print(f"✗ Error creating Enhanced ResNet: {e}")
                        print("Falling back to standard ResNet (CAFO/FF training won't work)")
                        # Remove CAFO/FF flags for fallback
                        model_config['use_cafo'] = False
                        model_config['use_forward_forward'] = False
                        model = CNNFactory.create_model('resnet', model_config)
                else:
                    # Standard training mode
                    print(f"\\nCreating standard ResNet for backpropagation...")
                    model = CNNFactory.create_model('resnet', model_config)
                
                print(f"\\nModel created with {model.get_num_parameters() if hasattr(model, 'get_num_parameters') else sum(p.numel() for p in model.parameters()):,} parameters")
                
                # Get model info
                model_info = model.get_model_info() if hasattr(model, 'get_model_info') else {}
                model_info['model_name'] = args.model_name
                model_info['model_source'] = 'fresh_build'
                model_info['training_mode'] = 'CAFO' if use_cafo else 'Forward-Forward' if use_forward_forward else 'Backpropagation'
                model_info['model_class'] = model.__class__.__name__
                
            except Exception as e:
                print(f"Failed to create model: {e}")
                sys.exit(1)

            # Save model with proper checkpoint format
            checkpoint = {
                'config': model_config,
                'model_state_dict': model.state_dict(),
                'model_info': model_info,
                'training_mode': 'CAFO' if use_cafo else 'Forward-Forward' if use_forward_forward else 'Backpropagation'
            }
            
            torch.save(checkpoint, args.model_out)

            # Save updated config
            config['model'] = model_config
            with open(args.config_updated, 'w') as f:
                json.dump(config, f, indent=2)
                
            # Save model info
            with open(args.model_info_out, 'w') as f:
                json.dump(model_info, f, indent=2)

            print(f"\\n✓ Model built and saved to: {args.model_out}")
            print(f"✓ Updated config saved to: {args.config_updated}")
            print(f"✓ Model info saved to: {args.model_info_out}")
        
    args:
      - --model_name
      - {inputValue: model_name}
      - --config_str
      - {inputValue: config_str}
      - --load_from_cdn
      - {inputValue: load_from_cdn}
      - --cdn_url
      - {inputValue: cdn_url}
      - --model_out
      - {outputPath: model_out}
      - --config_updated
      - {outputPath: config_updated}
      - --model_info_out
      - {outputPath: model_info_out}
