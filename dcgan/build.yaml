name: Build Model v2
description: Builds DCGAN model using single master config
inputs:
  - name: master_config
    type: String
  - name: load_from_cdn
    type: String
    default: "false"
  - name: cdn_url
    type: String
outputs:
  - name: model_out
    type: Model
  - name: config_updated
    type: String
  - name: model_info_out
    type: String

implementation:
  container:
    image: deepak0147/nessy-facotry:0.0.8
    command:
      - sh
      - -c
      - |
        echo "Checking for torchvision..."
        python3 -c "import torchvision; print(f'torchvision version: {torchvision.__version__}')" 2>/dev/null || {
          echo "torchvision not found, installing 0.17.0..."
          pip install torchvision==0.17.0 pillow
        }
        echo "Building DCGAN Model with master config..."
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import torch
        import argparse
        import json
        import os
        import sys
        import tempfile
        import urllib.request
        
        # Import the module dynamically to handle any import issues
        print("Importing nesy_factory.GANs.dcgan...")
        
        try:
            # First try to import directly
            from nesy_factory.GANs.dcgan import create_dcgan, DEFAULT_DCGAN_CONFIG
            print(" Successfully imported create_dcgan directly")
        except ImportError:
            # If direct import fails, import the module and get the function
            print(" Direct import failed, trying module import...")
            try:
                import nesy_factory.GANs.dcgan as dcgan_module
                
                # Get create_dcgan from the module
                if hasattr(dcgan_module, 'create_dcgan'):
                    create_dcgan = dcgan_module.create_dcgan
                    DEFAULT_DCGAN_CONFIG = dcgan_module.DEFAULT_DCGAN_CONFIG
                    print(" Successfully imported from module")
                else:
                    print(f" create_dcgan not found in module")
                    print(f"Available attributes: {[attr for attr in dir(dcgan_module) if not attr.startswith('_')][:20]}...")
                    sys.exit(1)
            except Exception as e:
                print(f" Failed to import nesy_factory.GANs.dcgan: {e}")
                sys.exit(1)
        
        parser = argparse.ArgumentParser()
        parser.add_argument('--master_config', type=str, required=True)
        parser.add_argument('--load_from_cdn', type=str, default='false')
        parser.add_argument('--cdn_url', type=str, default='')
        parser.add_argument('--model_out', type=str, required=True)
        parser.add_argument('--config_updated', type=str, required=True)
        parser.add_argument('--model_info_out', type=str, required=True)
        args = parser.parse_args()
        
        load_from_cdn = args.load_from_cdn.lower() == 'true'
        
        # Parse master config
        config = json.loads(args.master_config)
        gan_cfg = config['gan']
        dataset_cfg = config['dataset']
        
        # Create output directories
        os.makedirs(os.path.dirname(args.model_out), exist_ok=True)
        os.makedirs(os.path.dirname(args.config_updated), exist_ok=True)
        os.makedirs(os.path.dirname(args.model_info_out), exist_ok=True)
        
        if load_from_cdn:
            # MODE 1: Download model from CDN
            if not args.cdn_url:
                print("ERROR: cdn_url is required when load_from_cdn=true")
                sys.exit(1)
                
            print(f"Loading DCGAN model from CDN: {args.cdn_url}")
            
            try:
                with tempfile.NamedTemporaryFile(delete=False, suffix='.pth') as tmp_file:
                    tmp_path = tmp_file.name
                
                print(f"Downloading from {args.cdn_url}...")
                urllib.request.urlretrieve(args.cdn_url, tmp_path)
                print("Download completed")
                
                checkpoint = torch.load(tmp_path, map_location='cpu')
                torch.save(checkpoint, args.model_out)
                print(f"Model loaded from CDN and saved to: {args.model_out}")
                
                # Update config
                config['model_source'] = 'cdn'
                config['cdn_url'] = args.cdn_url
                
                with open(args.config_updated, 'w') as f:
                    json.dump(config, f, indent=2)
                
                model_info = {
                    'model_type': 'dcgan',
                    'model_source': 'cdn',
                    'cdn_url': args.cdn_url,
                    'checkpoint_keys': list(checkpoint.keys()) if isinstance(checkpoint, dict) else 'state_dict'
                }
                with open(args.model_info_out, 'w') as f:
                    json.dump(model_info, f, indent=2)
                    
                os.unlink(tmp_path)
                
            except Exception as e:
                print(f"Failed to load model from CDN: {e}")
                sys.exit(1)
                
        else:
            # MODE 2: Build new DCGAN model using master config
            print(f"Building new DCGAN model with master config...")
            
            try:
                # Convert master config to DCGAN library format
                dcgan_config = {
                    'dataset': {
                        'resize_size': dataset_cfg['image_size']
                    },
                    'generator': {
                        'z_dim': gan_cfg['z_dim'],
                        'hidden_dims': gan_cfg['generator']['hidden_dims'],
                        'image_channels': dataset_cfg['channels'],
                        'use_batchnorm': True,
                        'activation': 'relu',
                        'output_activation': 'tanh',
                        'learning_rate': gan_cfg['generator']['learning_rate'],
                        'loss_type': gan_cfg['generator']['loss_type'],
                        
                        # Layer configurations
                        'kernel_sizes': [4] * (len(gan_cfg['generator']['hidden_dims']) + 1),
                        'strides': [1] + [2] * len(gan_cfg['generator']['hidden_dims']),
                        'paddings': [0] * (len(gan_cfg['generator']['hidden_dims']) + 1),
                        'output_paddings': [0] * (len(gan_cfg['generator']['hidden_dims']) + 1),
                        
                        # FF/CAFO settings
                        'use_forward_forward': gan_cfg['generator'].get('use_forward_forward', False),
                        'use_cafo': gan_cfg['generator'].get('use_cafo', False),
                        'ff_epochs_per_block': gan_cfg['generator'].get('ff_epochs_per_block', 2),
                        'cafo_epochs_per_block': gan_cfg['generator'].get('cafo_epochs_per_block', 2)
                    },
                    'discriminator': {
                        'hidden_dims': gan_cfg['discriminator']['hidden_dims'],
                        'image_channels': dataset_cfg['channels'],
                        'use_batchnorm': False,
                        'activation': 'leaky_relu',
                        'output_activation': 'sigmoid',
                        'learning_rate': gan_cfg['discriminator']['learning_rate'],
                        'loss_type': gan_cfg['discriminator']['loss_type'],
                        'dropout': gan_cfg['discriminator'].get('dropout', 0.3),
                        'label_smoothing': 0.0,
                        'n_critic': 1,
                        
                        # Layer configurations
                        'kernel_sizes': [4] * len(gan_cfg['discriminator']['hidden_dims']),
                        'strides': [2] * (len(gan_cfg['discriminator']['hidden_dims']) - 1) + [1],
                        'paddings': [1] * (len(gan_cfg['discriminator']['hidden_dims']) - 1) + [0],
                        'output_dim': 1,
                        
                        # FF/CAFO settings
                        'use_forward_forward': gan_cfg['discriminator'].get('use_forward_forward', False),
                        'use_cafo': gan_cfg['discriminator'].get('use_cafo', False),
                        'ff_epochs_per_block': gan_cfg['discriminator'].get('ff_epochs_per_block', 2),
                        'cafo_epochs_per_block': gan_cfg['discriminator'].get('cafo_epochs_per_block', 2)
                    }
                }
                
                # Set algorithm-specific flags
                algorithm = gan_cfg['training']['algorithm']
                if algorithm == 'forward_forward':
                    dcgan_config['discriminator']['use_forward_forward'] = True
                    print(f"   Forward-Forward enabled for discriminator")
                elif algorithm == 'cafo':
                    dcgan_config['generator']['use_cafo'] = True
                    dcgan_config['discriminator']['use_cafo'] = True
                    print(f"   CAFO enabled for both generator and discriminator")
                else:
                    print(f"   Standard Backpropagation")
                
                print(f"\\n  DCGAN CONFIG SUMMARY:")
                print(f"  Image Size: {dcgan_config['dataset']['resize_size']}x{dcgan_config['dataset']['resize_size']}")
                print(f"  Channels: {dataset_cfg['channels']}")
                print(f"  Generator z_dim: {dcgan_config['generator']['z_dim']}")
                print(f"  Generator layers: {len(dcgan_config['generator']['hidden_dims'])}")
                print(f"  Discriminator layers: {len(dcgan_config['discriminator']['hidden_dims'])}")
                
                # Create DCGAN models using the imported function
                generator, discriminator, full_config = create_dcgan(dcgan_config)
                
                print(f"\\n MODELS CREATED:")
                print(f"  Generator parameters: {sum(p.numel() for p in generator.parameters()):,}")
                print(f"  Discriminator parameters: {sum(p.numel() for p in discriminator.parameters()):,}")
                
                # Create model info
                model_info = {
                    'model_type': 'dcgan',
                    'model_source': 'fresh_build',
                    'training_algorithm': algorithm,
                    'generator_params': sum(p.numel() for p in generator.parameters()),
                    'discriminator_params': sum(p.numel() for p in discriminator.parameters()),
                    'total_params': sum(p.numel() for p in generator.parameters()) + sum(p.numel() for p in discriminator.parameters()),
                    'z_dim': generator.z_dim,
                    'image_channels': generator.image_channels,
                    'image_size': generator.image_size,
                    'config_source': 'master_config'
                }
                
                # Save both models in a checkpoint
                checkpoint = {
                    'config': full_config,
                    'generator_state_dict': generator.state_dict(),
                    'discriminator_state_dict': discriminator.state_dict(),
                    'model_info': model_info,
                    'model_type': 'dcgan',
                    'training_algorithm': algorithm,
                    'master_config': config  # Keep original master config
                }
                
                torch.save(checkpoint, args.model_out)
                
                # Save updated config
                with open(args.config_updated, 'w') as f:
                    json.dump(full_config, f, indent=2)
                    
                # Save model info
                with open(args.model_info_out, 'w') as f:
                    json.dump(model_info, f, indent=2)
                    
                print(f"\\n DCGAN model built successfully!")
                print(f"  Saved to: {args.model_out}")
                
            except Exception as e:
                print(f" ERROR: Failed to build DCGAN model: {e}")
                import traceback
                traceback.print_exc()
                sys.exit(1)

    args:
      - --master_config
      - {inputValue: master_config}
      - --load_from_cdn
      - {inputValue: load_from_cdn}
      - --cdn_url
      - {inputValue: cdn_url}
      - --model_out
      - {outputPath: model_out}
      - --config_updated
      - {outputPath: config_updated}
      - --model_info_out
      - {outputPath: model_info_out}
