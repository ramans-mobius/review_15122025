name: I Update Schema Row v14
description: Updates a row in a schema based on a mapping between column names and a JSON object.

inputs:
  - { name: schema_id, type: String, description: "The ID of the schema to update." }
  - { name: update_data_json, type: String, description: "JSON string containing the data to update." }
  - { name: mapping_json, type: String, description: "JSON string mapping column names to keys in update_data_json." }
  - { name: model_id, type: String, description: "The ID of the model to filter by." }
  - { name: execution_id, type: String, description: "The ID of the model to filter by." }
  - { name: tenant_id, type: string, description: "The ID of the tenant." }
  - { name: project_id, type: String, description: "The ID of the project." }
  - { name: architecture_type, type: String, description: "The architecture type." }
  - { name: multiple_rows_json, type: String, description: "JSON string containing a list of rows to create." }
  - { name: bearer_auth_token, type: string, description: "Bearer token for authentication." }
  - { name: domain, type: String, description: "The domain for the API endpoint." }
  - { name: float_keys_json, type: String, description: "JSON string of a list of keys to be converted to float.", default: '[]'}
  - { name: trained_model_cdn_url, type: String, description: "CDN URL string for trained model.", default: '-1'}
  - { name: model_metadata_cdn_url, type: String, description: "CDN URL string for model metadata.", default: '-1'}
  - { name: training_metrics_path, type: String, description: "Training metrics JSON string.", default: '-1' }
  - { name: model_config_json, type: String, description: "Model configuration JSON string.", default: '-1'}
  - { name: evaluation_metrics_path, type: String, description: "Evaluation metrics JSON string.", default: '-1'}

implementation:
  container:
    image: python:3.9-slim
    command:
      - sh
      - -c
      - |
        pip install requests
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import json
        import argparse
        import requests
        import os
        import datetime
        from urllib.parse import quote, unquote
        from requests.adapters import HTTPAdapter
        from urllib3.util.retry import Retry
        
        # Helper function to get current datetime in ISO format
        def get_current_datetime():
            return datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        # Helper function to create requests session with retry logic
        def create_session():
            session = requests.Session()
            retry_strategy = Retry(
                total=3,
                backoff_factor=1,
                status_forcelist=[429, 500, 502, 503, 504],
            )
            adapter = HTTPAdapter(max_retries=retry_strategy)
            session.mount("http://", adapter)
            session.mount("https://", adapter)
            return session
        
        # Helper function to read file content
        def read_file_content(filepath):
            if filepath != '-1' and os.path.exists(filepath):
                with open(filepath, 'r') as f:
                    content = f.read().strip()
                    return content if content else None
            return None
        
        # Helper function to parse JSON from either file or direct string
        def parse_json_input(input_value, is_file_path=False):
            if input_value == '-1':
                return None
            try:
                if is_file_path:
                    content = read_file_content(input_value)
                    if content:
                        return json.loads(content)
                    return None
                else:
                    return json.loads(input_value)
            except json.JSONDecodeError as e:
                print(f"Warning: Failed to parse JSON input: {e}")
                return None
            except Exception as e:
                print(f"Warning: Error reading input: {e}")
                return None
        
        # Helper function to extract metrics from training metrics
        def extract_metrics_from_training(training_metrics):
            extracted = {}
            if not training_metrics:
                return extracted
            
            try:
                if isinstance(training_metrics, str):
                    metrics_data = json.loads(training_metrics)
                else:
                    metrics_data = training_metrics
                
                # Extract parameter count
                if 'parameter_count' in metrics_data:
                    extracted['parameter_count'] = metrics_data['parameter_count']
                
                # Extract model architecture info
                if 'model_architecture' in metrics_data:
                    arch = metrics_data['model_architecture']
                    if 'input_shape' in arch:
                        extracted['input_shape'] = str(arch['input_shape'])
                    if 'output_shape' in arch:
                        extracted['output_shape'] = str(arch['output_shape'])
                    if 'name' in arch:
                        extracted['name'] = arch['name']
                    if 'architecture_type' in arch:
                        extracted['architecture_type'] = arch['architecture_type']
                
                # Extract final loss
                if 'final_epoch_metrics' in metrics_data:
                    final_metrics = metrics_data['final_epoch_metrics']
                    if 'loss' in final_metrics:
                        extracted['final_loss'] = final_metrics['loss']
                
                # Extract other relevant metrics
                for key in ['latent_dim', 'learning_rate', 'batch_size']:
                    if key in metrics_data:
                        extracted[key] = metrics_data[key]
                        
            except Exception as e:
                print(f"Error extracting training metrics: {e}")
            
            return extracted
        
        # Helper function to extract metrics from evaluation
        def extract_metrics_from_evaluation(evaluation_metrics):
            extracted = {}
            if not evaluation_metrics:
                return extracted
            
            try:
                if isinstance(evaluation_metrics, str):
                    eval_data = json.loads(evaluation_metrics)
                else:
                    eval_data = evaluation_metrics
                
                # Extract evaluation metrics
                if 'metrics' in eval_data:
                    metrics = eval_data['metrics']
                    for key, value in metrics.items():
                        extracted[f'eval_{key}'] = value
                
                # Extract model performance summary
                if 'summary' in eval_data:
                    summary = eval_data['summary']
                    for key, value in summary.items():
                        extracted[f'summary_{key}'] = value
                        
            except Exception as e:
                print(f"Error extracting evaluation metrics: {e}")
            
            return extracted
        
        # Main execution
        parser = argparse.ArgumentParser()
        parser.add_argument('--schema_id', type=str, required=True)
        parser.add_argument('--update_data_json', type=str, required=True)
        parser.add_argument('--mapping_json', type=str, required=True)
        parser.add_argument('--model_id', type=str, required=True)
        parser.add_argument('--execution_id', type=str, required=True)
        parser.add_argument('--tenant_id', type=str, required=True)
        parser.add_argument('--project_id', type=str, required=True)
        parser.add_argument('--architecture_type', type=str, required=True)
        parser.add_argument('--multiple_rows_json', type=str, required=True)
        parser.add_argument('--bearer_auth_token', type=str, required=True)
        parser.add_argument('--domain', type=str, required=True)
        parser.add_argument('--float_keys_json', type=str, required=False)
        parser.add_argument('--trained_model_cdn_url', type=str, required=False)
        parser.add_argument('--model_metadata_cdn_url', type=str, required=False)
        parser.add_argument('--training_metrics_path', type=str, required=False)
        parser.add_argument('--model_config_json', type=str, required=False)
        parser.add_argument('--evaluation_metrics_path', type=str, required=False)
        args = parser.parse_args()
        
        execution_id_int = int(args.execution_id)
        
        with open(args.bearer_auth_token, 'r') as f:
            bearer_auth_token = f.read().strip()
        
        with open(args.tenant_id, 'r') as f:
            tenant_id = f.read().strip()
        
        print("=" * 80)
        print("UPDATE SCHEMA ROW WITH MODEL METADATA")
        print("=" * 80)
        
        print(f" Input Data ")
        print(f"update_data_json: {args.update_data_json}")
        print(f"mapping_json: {args.mapping_json}")
        print(f"model_id: {args.model_id}")
        
        # Parse inputs - note which ones are file paths vs direct strings
        update_data = parse_json_input(args.update_data_json, is_file_path=False)
        mapping = parse_json_input(args.mapping_json, is_file_path=False)
        
        # Parse float_keys - this is a file path
        float_keys = []
        if args.float_keys_json and args.float_keys_json != '-1':
            try:
                # First try to read as file path
                float_keys_data = parse_json_input(args.float_keys_json, is_file_path=True)
                if float_keys_data is not None:
                    float_keys = float_keys_data
                else:
                    # If that fails, try to parse as direct JSON string
                    float_keys = parse_json_input(args.float_keys_json, is_file_path=False) or []
            except Exception as e:
                print(f"Warning: Failed to parse float_keys_json: {e}")
                float_keys = []
        
        # For debugging
        print(f"float_keys: {float_keys}")
        
        # Read additional files
        model_weights_cdn = read_file_content(args.trained_model_cdn_url) if args.trained_model_cdn_url != '-1' else None
        model_metadata_cdn = read_file_content(args.model_metadata_cdn_url) if args.model_metadata_cdn_url != '-1' else None
        
        # Parse JSON files
        training_metrics = parse_json_input(args.training_metrics_path, is_file_path=True) if args.training_metrics_path != '-1' else None
        model_config = parse_json_input(args.model_config_json, is_file_path=True) if args.model_config_json != '-1' else None
        evaluation_metrics = parse_json_input(args.evaluation_metrics_path, is_file_path=True) if args.evaluation_metrics_path != '-1' else None
        
        # Extract metrics
        extracted_metrics = {}
        if training_metrics:
            extracted_metrics.update(extract_metrics_from_training(training_metrics))
        if evaluation_metrics:
            extracted_metrics.update(extract_metrics_from_evaluation(evaluation_metrics))
        
        # Create HTTP session
        http = create_session()
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {bearer_auth_token}',
            'X-Tenant-Id': tenant_id
        }
        
        if args.multiple_rows_json != '-1':
            multiple_rows = parse_json_input(args.multiple_rows_json, is_file_path=False)
            print(f"Processing multiple rows: {len(multiple_rows)} rows found")
        else:
            check_url = f"{args.domain}/pi-entity-instances-service/v3.0/schemas/{args.schema_id}/instances/list"
            check_payload = {
                "dbType": "TIDB",
                "ownedOnly": True,
                "filter": {
                    "execution_id": execution_id_int
                }
            }
            
            print(f"\\n Checking for Existing Row with execution_id: {execution_id_int} ")
            print(f"Request URL: POST {check_url}")
            print(f"Request Headers: {json.dumps(headers)}")
            print(f"Request Payload: {json.dumps(check_payload, indent=2)}")
        
            try:
                response = http.post(check_url, headers=headers, data=json.dumps(check_payload), timeout=60)
                response.raise_for_status()
                response_data = response.json()
                
                if response_data.get("content"):
                    print(f" Instance Found: Updating Row ")
                    patch_requests = []
                    for column, keys in mapping.items():
                        value_to_patch = None
                        if isinstance(keys, list):
                            value_to_patch = {key: update_data.get(key) for key in keys if key in update_data}
                        else:
                            if keys in update_data:
                                value = update_data.get(keys)
                                if keys in float_keys:
                                    try:
                                        value_to_patch = float(value)
                                    except (ValueError, TypeError):
                                        value_to_patch = str(value)
                                else:
                                    value_to_patch = str(value)
        
                        if value_to_patch is not None:
                            patch_requests.append({
                                "operation": "REPLACE",
                                "path": column,
                                "value": value_to_patch
                            })
                    
                    # FIX 1: Add model_id to patch requests (it's a primary key)
                    if args.model_id != '-1':
                        patch_requests.append({
                            "operation": "REPLACE",
                            "path": "model_id",
                            "value": args.model_id
                        })
                    
                    # FIX 2: Set name from model_id or model_type
                    name_value = None
                    if 'name' in mapping:
                        # If mapping has name, use that
                        name_key = mapping['name']
                        if name_key in update_data:
                            name_value = str(update_data[name_key])
                    else:
                        # Use model_id as name
                        name_value = f"model_{args.model_id}"
                    
                    if name_value:
                        patch_requests.append({
                            "operation": "REPLACE",
                            "path": "name",
                            "value": name_value
                        })
                    
                    # Add other fields as before
                    if model_weights_cdn:
                        patch_requests.extend([
                            {
                                "operation": "REPLACE",
                                "path": "model_weights_cdn",
                                "value": model_weights_cdn
                            },
                            {
                                "operation": "REPLACE",
                                "path": "model_url",
                                "value": model_weights_cdn
                            }
                        ])
                    if model_metadata_cdn:
                        patch_requests.append({
                            "operation": "REPLACE",
                            "path": "model_metadata_cdn",
                            "value": model_metadata_cdn
                        })
                    
                    # Add model config
                    if model_config:
                        patch_requests.append({
                            "operation": "REPLACE",
                            "path": "model_specific_config",
                            "value": model_config
                        })
                    
                    # Add extracted metrics
                    for key, value in extracted_metrics.items():
                        if key in ['parameter_count', 'input_shape', 'output_shape', 'name', 'architecture_type']:
                            patch_requests.append({
                                "operation": "REPLACE",
                                "path": key,
                                "value": value
                            })
                    
                    # Add required fields if missing
                    if not any(p['path'] == 'name' for p in patch_requests):
                        patch_requests.append({
                            "operation": "REPLACE",
                            "path": "name",
                            "value": f"model_{args.model_id}"
                        })
                    
                    # Add source field
                    patch_requests.append({
                        "operation": "REPLACE",
                        "path": "source",
                        "value": "auto-generated"
                    })
                    
                    # Add experiment_id
                    patch_requests.append({
                        "operation": "REPLACE",
                        "path": "experiment_id",
                        "value": execution_id_int
                    })
        
                    update_url = f"{args.domain}/pi-entity-instances-service/v2.0/schemas/{args.schema_id}/instances"
                    update_payload = {
                        "dbType": "TIDB",
                        "conditionalFilter": {
                            "conditions": [
                                {
                                    "field": "execution_id",
                                    "operator": "EQUAL",
                                    "value": execution_id_int
                                },
                                # FIX 3: Add model_id to filter (it's a primary key)
                                {
                                    "field": "model_id",
                                    "operator": "EQUAL",
                                    "value": args.model_id
                                }
                            ]
                        },
                        "partialUpdateRequests": [
                            {
                                "patch": patch_requests
                            }
                        ]
                    }
                    
                    print(f"\\nRequest URL: PATCH {update_url}")
                    print(f"Request Headers: {json.dumps(headers)}")
                    print(f"Request Payload: {json.dumps(update_payload, indent=2)}")
                    
                    response = http.patch(update_url, headers=headers, data=json.dumps(update_payload), timeout=60)
                    response.raise_for_status()
                    print("Successfully updated the model instance.")
                else:
                    print(f" No Instance Found: Creating New Row ")
                    creation_data = {}
                    for column, keys in mapping.items():
                        value_to_add = None
                        if isinstance(keys, list):
                            value_to_add = {key: update_data.get(key) for key in keys if key in update_data}
                        else:
                            if keys in update_data:
                                value = update_data.get(keys)
                                if keys in float_keys:
                                    try:
                                        value_to_add = float(value)
                                    except (ValueError, TypeError):
                                        value_to_add = str(value)
                                else:
                                    value_to_add = str(value)
        
                        if value_to_add is not None:
                            creation_data[column] = value_to_add
                    
                    # FIX 4: Set required primary key fields
                    creation_data['execution_id'] = execution_id_int
                    creation_data['model_id'] = args.model_id  # Primary key
                    creation_data['tenant_id'] = tenant_id
                    creation_data['projectId'] = args.project_id
                    
                    # FIX 5: Set name from model_id or model_type
                    if 'name' in creation_data:
                        # If name already set from mapping, keep it
                        pass
                    elif 'model_type' in update_data:
                        creation_data['name'] = str(update_data['model_type'])
                    else:
                        creation_data['name'] = f"model_{args.model_id}"
                    
                    creation_data['source'] = 'auto-generated'
                    creation_data['created_by'] = 'training_pipeline'
                    creation_data['experiment_id'] = execution_id_int
                    
                    # Set architecture_type with ENUM validation
                    if args.architecture_type != '-1':
                        arch_type = args.architecture_type
                        if arch_type.lower() == 'fully_connected':
                            creation_data['architecture_type'] = 'FFN'
                        elif arch_type.lower() == 'convolutional':
                            creation_data['architecture_type'] = 'CNN'
                        elif arch_type.lower() == 'transformer':
                            creation_data['architecture_type'] = 'transformer'
                        else:
                            creation_data['architecture_type'] = 'FFN'  # Default
                    
                    # Set CDN URLs
                    if model_weights_cdn:
                        creation_data['model_weights_cdn'] = model_weights_cdn
                        creation_data['model_url'] = model_weights_cdn
                    if model_metadata_cdn:
                        creation_data['model_metadata_cdn'] = model_metadata_cdn
                        if 'model_url' not in creation_data:
                            creation_data['model_url'] = model_metadata_cdn
                    if model_config:
                        creation_data['model_specific_config'] = model_config
                    
                    # Add extracted metrics
                    for key, value in extracted_metrics.items():
                        if key in ['parameter_count', 'input_shape', 'output_shape', 'name', 'architecture_type', 'model_specific_config']:
                            creation_data[key] = value
                        elif key == 'latent_dim' and 'parameter_count' not in creation_data:
                            creation_data['parameter_count'] = value
                        elif key == 'final_loss' and 'symbolic_profile' not in creation_data:
                            creation_data['symbolic_profile'] = f"Final loss: {value}"
                    
                    # Ensure name is set
                    if 'name' not in creation_data:
                        creation_data['name'] = f"model_{args.model_id}"
        
                    create_url = f"{args.domain}/pi-entity-instances-service/v2.0/schemas/{args.schema_id}/instances"
                    create_payload = {
                        "data": [creation_data]
                    }
        
                    print(f"\\nRequest URL: POST {create_url}")
                    print(f"Request Headers: {json.dumps(headers)}")
                    print(f"Request Payload: {json.dumps(create_payload, indent=2)}")
                    
                    response = http.post(create_url, headers=headers, data=json.dumps(create_payload), timeout=60)
                    if response.status_code >= 400:
                        print(f"Error: {response.status_code} {response.reason}")
                        print(f"Response Content: {response.text}")
                    response.raise_for_status()
                    print("Successfully created a new model instance.")
                    
                print(f"\\nResponse: {response.json()}")
        
            except requests.exceptions.RequestException as e:
                print(f"Error: {e}")
                if e.response is not None:
                    print(f"Response Status Code: {e.response.status_code}")
                    print(f"Response Content: {response.text}")
                exit(1)
        
        print("\\n" + "=" * 80)
        print("UPDATE COMPLETE")
        print("=" * 80)
    args:
      - --schema_id
      - {inputValue: schema_id}
      - --update_data_json
      - {inputValue: update_data_json}
      - --mapping_json
      - {inputValue: mapping_json}
      - --model_id
      - {inputValue: model_id}
      - --execution_id
      - {inputValue: execution_id}
      - --tenant_id
      - {inputPath: tenant_id}
      - --project_id
      - {inputValue: project_id}
      - --architecture_type
      - {inputValue: architecture_type}
      - --multiple_rows_json
      - {inputValue: multiple_rows_json}
      - --bearer_auth_token
      - {inputPath: bearer_auth_token}
      - --domain
      - {inputValue: domain}
      - --float_keys_json
      - {inputPath: float_keys_json}
      - --trained_model_cdn_url
      - {inputPath: trained_model_cdn_url}
      - --model_metadata_cdn_url
      - {inputPath: model_metadata_cdn_url}
      - --training_metrics_path
      - {inputPath: training_metrics_path}
      - --model_config_json
      - {inputPath: model_config_json}
      - --evaluation_metrics_path
      - {inputPath: evaluation_metrics_path}
